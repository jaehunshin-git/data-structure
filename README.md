# 자료구조 실습 코드 (Data Structure Practice Codes)

이 저장소는 자료구조 수업 중 직접 코드를 작성하며 실습한 다양한 자료구조 구현 코드을 모아둔 곳입니다. 각 자료구조의 기본적인 개념과 동작 방식을 이해하고 직접 구현해보는 데 중점을 두었습니다.

## 구현된 자료구조 목록

### 1. 배열 (Array)

* **2D 배열 (Snail Pattern)**
  * **특징**: 2차원 배열을 시계 방향으로 나선형으로 채워나가는 패턴을 구현합니다. 배열의 인덱싱과 반복문 제어를 통해 특정 패턴을 생성하는 연습을 할 수 있습니다.
  * **관련 파일**: [`Array/2DArray/snail2dArr.py`](Array/2DArray/snail2dArr.py)
  * **코드 설명**: `snail2dArr.py`는 주어진 `rows`와 `cols` 크기의 2차원 배열을 생성하고, 0부터 시작하여 숫자를 시계 방향으로 나선형으로 채워 넣는 `clockwiseSnail2dArr` 함수를 구현합니다. 배열의 경계를 `start_row`, `end_row`, `start_col`, `end_col` 변수로 관리하며, 각 방향(오른쪽, 아래, 왼쪽, 위)으로 이동하며 숫자를 채우고 경계를 좁혀나가는 방식으로 동작합니다.
  * **학습 내용**: 2차원 배열의 인덱스를 조작하여 복잡한 패턴을 구현하는 방법을 익혔습니다. 특히, `while` 루프와 네 방향으로의 `for` 루프를 조합하여 배열의 경계를 동적으로 조절하는 방식이 나선형 패턴을 구현하는 핵심 원리임을 이해했습니다. 배열의 경계 조건 처리와 반복문의 순서가 정확한 패턴을 만드는 데 중요함을 깨달았습니다.

### 2. 힙 (Heap)

* **최소 힙 (Min-Heap) - 배열 기반**
  * **특징**: 완전 이진 트리의 한 종류로, 부모 노드의 값이 항상 자식 노드의 값보다 작거나 같은(최소 힙의 경우) 특성을 가집니다. 우선순위 큐 구현에 주로 사용됩니다. 배열을 이용하여 효율적으로 구현할 수 있습니다.
  * **관련 파일**: [`Heap/MinHeap/minHeapUsingArray.py`](Heap/MinHeap/minHeapUsingArray.py)
  * **코드 설명**: `minHeapUsingArray.py`는 배열을 사용하여 최소 힙을 구현합니다. `insert` 함수는 새로운 요소를 힙의 마지막에 추가한 후 `heapify_up`을 통해 최소 힙 속성을 유지하고, `delete_min` 함수는 루트(최소값)를 제거하고 마지막 요소를 루트로 옮긴 후 `heapify_down`을 통해 힙 속성을 복원합니다. 또한, `visualize_heap` 함수를 통해 힙의 구조를 시각적으로 확인할 수 있도록 구현하여 힙의 계층적 구조를 명확히 이해하는 데 도움을 줍니다.
  * **학습 내용**: 힙이 배열로 어떻게 효율적으로 표현되는지(부모-자식 노드 인덱스 관계: `2*i+1`, `2*i+2`)를 직접 구현하며 체득했습니다. `heapify_up`과 `heapify_down` 연산이 힙의 핵심이며, 이 두 연산을 통해 삽입과 삭제 시 힙의 속성을 유지하는 원리를 깊이 이해할 수 있었습니다. 특히, 시각화 코드를 통해 힙의 논리적인 트리 구조가 배열에 어떻게 매핑되는지 눈으로 확인하며 개념을 더욱 확고히 할 수 있었습니다.

### 3. 연결 리스트 (Linked List)

* **단일 연결 리스트 (Singly Linked List) - 역방향 변환**
  * **특징**: 각 노드가 데이터와 다음 노드를 가리키는 링크를 가지는 선형 자료구조입니다. 배열과 달리 메모리에 연속적으로 저장되지 않으며, 삽입/삭제가 용이합니다.
  * **관련 파일**: [`LinkedList/Single/reverse.py`](LinkedList/Single/reverse.py)
  * **코드 설명**: `reverse.py`는 단일 연결 리스트를 역방향으로 뒤집는 기능을 구현합니다. 이 과정에서 `prev`, `curr`, `next_node`와 같은 포인터(참조) 변수를 사용하여 노드들의 연결 순서를 변경합니다.
  * **학습 내용**: 연결 리스트의 노드 간 연결을 변경하는 것이 배열의 인덱스 조작과는 근본적으로 다름을 이해했습니다. 특히, 리스트를 역방향으로 뒤집을 때 세 개의 포인터를 사용하여 현재 노드의 `next` 포인터를 이전 노드를 가리키도록 변경하고, 각 포인터를 한 칸씩 이동시키는 과정이 매우 중요하며, 이 과정을 통해 메모리 효율적으로 리스트의 구조를 변경할 수 있음을 깨달았습니다.

### 4. 스택 (Stack)

* **특징**: LIFO(Last In, First Out) 원칙을 따르는 선형 자료구조입니다. 주로 함수 호출 스택, 괄호 매칭, 수식 계산 등에 활용됩니다.
  * **관련 파일**: [`Stack/task.txt`](Stack/task.txt) (관련 실습 과제 명시)
  * **코드 설명**: `Stack/task.txt`에 명시된 바와 같이, 괄호 매칭(`( ) check`, `<[{()}]> pair judge`)과 팰린드롬 판단(`Palindrome judge`)과 같은 스택의 대표적인 응용 사례들을 실습했습니다. 이 과제들은 스택의 LIFO 특성을 활용하여 문자열의 유효성을 검사하거나 특정 패턴을 확인하는 데 스택이 어떻게 사용되는지 보여줍니다.
  * **학습 내용**: 스택이 후입선출(LIFO) 원칙을 통해 특정 순서의 데이터를 처리하는 데 매우 유용하다는 것을 괄호 매칭과 팰린드롬 검사를 통해 명확히 이해했습니다. 특히, 여는 괄호를 만나면 스택에 푸시하고 닫는 괄호를 만나면 스택에서 팝하여 짝이 맞는지 확인하는 과정에서 스택의 활용 가치를 깊이 깨달았습니다.

### 5. 큐 (Queue)

* **특징**: FIFO(First In, First Out) 원칙을 따르는 선형 자료구조입니다. 먼저 들어온 요소가 먼저 나가는 특성 때문에 대기열, 버퍼, 너비 우선 탐색(BFS) 등 다양한 상황에서 사용됩니다.
  * **관련 파일**: [`Queue/aboutQueue.txt`](Queue/aboutQueue.txt)
  * **코드 설명**: `Queue/aboutQueue.txt` 파일은 큐의 핵심 특징인 FIFO(First In, First Out) 원칙을 명시하고 있습니다. 이는 큐의 기본적인 개념을 이해하고 정리하는 데 사용되었습니다.
  * **학습 내용**: 큐의 FIFO 원칙이 실제 시스템에서 어떻게 대기열을 관리하고 순서를 보장하는지 개념적으로 이해했습니다. 스택과 대조하여 큐가 어떤 상황에 더 적합한지 구분하는 능력을 키웠습니다.

### 6. 트리 (Tree)

* **이진 탐색 트리 (Binary Search Tree - BST)**
  * **특징**: 이진 트리의 한 종류로, 모든 노드에 대해 왼쪽 서브트리의 모든 노드 값은 현재 노드 값보다 작고, 오른쪽 서브트리의 모든 노드 값은 현재 노드 값보다 큰 특성을 가집니다. 효율적인 탐색, 삽입, 삭제가 가능합니다.
  * **관련 파일**: [`Tree/BinaryTree/myDLLTree2.py`](Tree/BinaryTree/myDLLTree2.py)
  * **코드 설명**: `myDLLTree2.py`는 이진 탐색 트리의 구현을 목표로 합니다. 이 파일은 노드의 삽입, 삭제, 탐색 등 BST의 기본 연산을 포함할 것으로 예상됩니다. `bstLogic.txt`는 Notion에 관련 내용을 정리하라는 지시를 담고 있어, 이론적 이해와 코드 구현을 병행했음을 시사합니다.
  * **학습 내용**: 이진 탐색 트리가 데이터를 효율적으로 저장하고 검색하는 데 어떻게 사용되는지 그 원리를 이해했습니다. 특히, 왼쪽 자식은 부모보다 작고 오른쪽 자식은 부모보다 크다는 규칙이 탐색 성능을 O(log N)으로 유지하는 핵심임을 깨달았습니다. 재귀적인 구조와 노드 간의 관계를 코드로 표현하는 연습을 통해 트리 자료구조의 복잡성을 다루는 능력을 향상시켰습니다.

### 7. 탐색 (Search)

* **이진 탐색 (Binary Search)**
  * **특징**: 정렬된 배열에서 특정 값을 찾는 효율적인 알고리즘입니다. 탐색 범위를 절반씩 줄여나가며 빠르게 목표 값을 찾습니다.
  * **관련 파일**: [`Search/task.txt`](Search/task.txt) (관련 실습 과제 명시)
  * **코드 설명**: `Search/task.txt`에 "binary search with iteration"이라고 명시되어 있어, 반복문을 사용하여 이진 탐색 알고리즘을 구현했음을 알 수 있습니다. 이진 탐색은 정렬된 배열에서 중간 값을 기준으로 탐색 범위를 절반씩 줄여나가는 방식으로 동작합니다.
  * **학습 내용**: 이진 탐색이 정렬된 데이터에서 얼마나 효율적으로 작동하는지 그 원리를 이해했습니다. 특히, `low`, `high`, `mid` 인덱스를 사용하여 탐색 범위를 좁혀나가는 반복적인 과정이 선형 탐색보다 훨씬 빠르다는 것을 깨달았습니다. 재귀적 구현과 반복적 구현의 차이점을 비교하며 알고리즘 구현 방식에 대한 이해를 넓혔습니다.

### 8. 시각화 (Visualization)

* **특징**: 자료구조의 내부 동작이나 구조를 시각적으로 표현하여 이해를 돕는 유틸리티 코드입니다. 특히 힙과 같은 트리 기반 자료구조의 시각화에 활용됩니다.
  * **관련 파일**: [`Visualize/visualize.py`](Visualize/visualize.py)
  * **코드 설명**: `visualize.py`는 `matplotlib`과 `networkx` 라이브러리를 활용하여 힙과 같은 트리 기반 자료구조를 시각적으로 표현하는 `visualize_heap` 함수를 포함합니다. 이 함수는 힙의 배열 표현을 그래프 형태로 변환하여 노드와 간선을 그리고, 이를 이미지 파일로 저장하여 사용자가 힙의 구조를 직관적으로 이해할 수 있도록 돕습니다. `visualizer.txt`는 트리, 힙, 그래프 등 다양한 자료구조의 시각화를 목표로 함을 보여줍니다.
  * **학습 내용**: 추상적인 자료구조의 개념을 시각적으로 표현하는 것이 이해도를 높이는 데 얼마나 중요한지 깨달았습니다. 특히, 힙의 배열 기반 구현이 실제로는 트리 구조를 형성한다는 것을 시각화를 통해 명확히 확인하며, 이론과 실제 구현 사이의 간극을 줄일 수 있었습니다. 디버깅이나 학습 과정에서 시각화 도구가 매우 유용하다는 것을 체감했습니다.
